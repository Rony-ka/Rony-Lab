<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Rotation Grid</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
            font-family: "Inter", sans-serif;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }

        body {
            background-color: #0E0E0E;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            grid-template-rows: repeat(auto-fill, minmax(45px, 1fr));
            width: 100vw;
            height: 100vh;
            padding: 0;
            overflow: hidden;
        }

        .line {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .line::before {
            content: '';
            background-color: var(--c, transparent);
            width: var(--w, 1.5px);
            height: 46px;
            opacity: var(--o, 0);
            transition: opacity 0.4s ease-out;
        }
    </style>
</head>
<body>
    <div id="grid-container"></div>

    <script>
        const grid = document.getElementById('grid-container');
        
        // Parameters
        const baseRadius = 100;
        const maxRadius = 400;
        const growthRate = 150;
        const maxMove = 40;
        const minW = 1.5;
        const maxW = 15;
        const lerp = 0.03; // Movement transitions
        const lerpWidth = 0.03; // Width transitions
        const radiusLerp = 0.05; // Gradual radius shrinking on release
        
        // Colors
        const c1 = [200, 128, 253];
        const c2 = [240, 61, 42];
        
        let lines = [];
        let mx = 0, my = 0, active = false;
        let down = false, downTime = 0, radius = baseRadius;
        let targetRadius = baseRadius; // For smooth radius transitions
        
        // Populate grid with fewer lines for better performance
        const populate = () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cols = Math.floor(w / 20);
            const rows = Math.floor(h / 45);
            
            // Reduce total lines for performance
            const total = Math.min(cols * rows, 2000);
            
            grid.innerHTML = '';
            lines = [];
            
            const frag = document.createDocumentFragment();
            for (let i = 0; i < total; i++) {
                const line = document.createElement('div');
                line.className = 'line';
                line.tx = 0;
                line.ttx = 0;
                line.w = minW;
                line.tw = minW;
                frag.appendChild(line);
                lines.push(line);
            }
            grid.appendChild(frag);
            
            // Cache positions once
            lines.forEach(line => {
                const r = line.getBoundingClientRect();
                line.cx = r.left + r.width / 2;
                line.cy = r.top + r.height / 2;
            });
        };
        
        const animate = () => {
            // Update target radius
            if (down) {
                const elapsed = (Date.now() - downTime) / 1000;
                targetRadius = Math.min(baseRadius + growthRate * elapsed, maxRadius);
            } else {
                targetRadius = baseRadius;
            }
            
            // Smoothly interpolate current radius toward target
            radius += (targetRadius - radius) * radiusLerp;
            
            const r2 = radius * radius;
            
            // Batch DOM updates
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                let ttx = 0, tw = minW, color = 'transparent', opacity = 0;
                
                if (active) {
                    const dx = mx - line.cx;
                    const dy = my - line.cy;
                    const d2 = dx * dx + dy * dy;
                    
                    if (d2 < r2) {
                        const d = Math.sqrt(d2);
                        const inf = 1 - d / radius;
                        const dir = dx > 0 ? 1 : -1;
                        ttx = -dir * inf * maxMove;
                        tw = minW + (maxW - minW) * inf;
                        const prog = Math.abs(ttx) / maxMove;
                        const r = Math.round(c1[0] + (c2[0] - c1[0]) * prog);
                        const g = Math.round(c1[1] + (c2[1] - c1[1]) * prog);
                        const b = Math.round(c1[2] + (c2[2] - c1[2]) * prog);
                        color = `rgb(${r},${g},${b})`;
                        opacity = 1;
                    }
                }
                
                line.tx += (ttx - line.tx) * lerp;
                line.w += (tw - line.w) * lerpWidth;
                
                // Apply updates directly
                line.style.transform = `translateX(${line.tx}px)`;
                line.style.setProperty('--w', `${line.w}px`);
                line.style.setProperty('--c', color);
                line.style.setProperty('--o', opacity);
            }
            
            requestAnimationFrame(animate);
        };
        
        // Events
        window.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const t = e.touches[0];
            mx = t.clientX;
            my = t.clientY;
            active = true;
            down = true;
            downTime = Date.now();
        }, { passive: false });
        
        window.addEventListener('touchmove', (e) => {
            const t = e.touches[0];
            mx = t.clientX;
            my = t.clientY;
        });
        
        window.addEventListener('touchend', () => {
            active = false;
            down = false;
        });
        
        window.addEventListener('mousemove', (e) => {
            mx = e.clientX;
            my = e.clientY;
            active = true;
        });
        
        window.addEventListener('mousedown', (e) => {
            down = true;
            downTime = Date.now();
        });
        
        window.addEventListener('mouseup', () => {
            down = false;
        });
        
        window.addEventListener('mouseleave', () => {
            active = false;
            down = false;
        });
        
        populate();
        animate();
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(populate, 200);
        });
    </script>
</body>
</html>